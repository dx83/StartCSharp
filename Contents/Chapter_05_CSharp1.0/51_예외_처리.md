### 예외 처리기 (exception handler)
> CLR은 예외 처리기가 있다면 해당 에외 처리기로 넘기고,<br>
> 없다면 예외 메시지를 출력하고 프로그램을 종료한다.
<br>

▼ try/catch 예약어
````csharp
int divisor = 0;
try
{
    // System.DivideByZeroException
    int quotient = 10 / divisor;
}
catch
{
    try
    {
        // 사용자 코드
    }
    catch  { }
}
````
- 프로그램이 종료되지 않고 실행 흐름이 catch 블록으로 넘어간다.
- try/catch 중첩이 가능하다.
<br>

▼ finally 예약어
````csharp
try
{
    int quotient = 10 / divisor;
    Console.WriteLine("예외가 발생하지 않으면 실행됨!");
}
catch
{
    Console.WriteLine("예외가 발생하면 실행됨!");
}
finally
{
    Console.WriteLine("언제나 실행됨!");
}
````
- 예외가 발생하는 것과 상관없이 언제나 실행된다.
- finally 블록은 자원을 해제하는 코드를 넣어두는 용도로 적합하다. (FileStream)
<br>

▼ catch 블록 : () 안에 System.Exception의 파생 타입
````csharp
int divisor = 0;
try
{
    int quotient = 10 / divisor;
}
catch (System.DivideByZeroException) { }
catch (Ssytem.NullReferenceException) { }
catch (System.Exception) { }
````
- catch 절에서 명시한 예외 타입의 예외가 발생한 경우, 남은 코드는 건너뛰고 즉시 catch 절 블록이 실행된다.
- catch 절에서 명시한 예외 타입 이외의 예외가 발생한 경우 프로그램이 비정상적으로 종료된다.
- catch 블록도 다중으로 구성할 수 있다.
- 상속 관계를 고려해 예외 타입을 지정해야 한다.<br>System.Exception이 맨 위에 있으면 그 아래의 catch 블록에 있는 코드는 결코 실행되지 않는다.
<br>

▼ catch 블록 : () 안에 예외 타입의 인스턴스 변수
````csharp
int divisor = 0;
try
{
    int quotient = 10 / divisor;
}
catch (System.DivideByZeroException e)
{
    Console.WriteLine(e.Message);
    Console.WriteLine(e.Source);
    Console.WriteLine(e.StackTrace);
    Console.WriteLine("-----------------");
    Console.WriteLine(e.ToString());
}
// 출력문
0으로 나누려 했습니다.
Chapter05
   위치: Chapter05.Exercise_51.Execute() 파일 C:\Workspace\_repos\StartCSharp_Study\Chapter05\Exercise_51.cs:줄 49
-----------------
System.DivideByZeroException: 0으로 나누려 했습니다.
   위치: Chapter05.Exercise_51.Execute() 파일 C:\Workspace\_repos\StartCSharp_Study\Chapter05\Exercise_51.cs:줄 49
````
- 위의 방법을 이용하면 프로그램이 실행되는 도중 발생하는 예외에 대해 기록하고 오류의 원인을 쉽게 찾을 수 있다.
<br>
